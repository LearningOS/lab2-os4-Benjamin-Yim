2022年12月11日
调试代码在11±0.5小时。
设置应用空间时间戳和任务信息读取。漏掉了 page_offset 导致一致不成功差不多排查测试了
三个小时左右，从之前简单的状态中考虑这个问题漏掉了 page_offset 这个偏移值。
从一开始的在内核中实施页内存分配。到在每个应用空间内分页内存，在调试代码的过程中一致修改 ummap 代码卡在了 ummap2 的第20行的 case，这里的 case 在经历了 6 个多小时的煎熬修改代码总以为代码写的不对一遍一遍的 review 最终没有办法的情况下看了测试的 case。才从中明白了错误的点，根据参考书提供的 start 需要页对齐但是只是提示在了 mmap ，误以为 unmap 中同样适用导致了耗费这么长时间，通过这里修改的经历收获了很多关于页内存分配和页内存释放的逻辑和原理，总之很 Nice

回答问题：
请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？
标志位代表了当前页的每个属性如下：
```
    pub struct PTEFlags: u8 {
        const V = 1 << 0; // 仅当 V(Valid) 位为 1 时，页表项才是合法的；
        const R = 1 << 1; // 可读
        const W = 1 << 2; // 可写
        const X = 1 << 3; // 可执行
        const U = 1 << 4; // 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问
        const G = 1 << 5; // 忽略
        const A = 1 << 6; // 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
        const D = 1 << 7; // 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过
    }
```
2. 缺页
    在理想状态下物理内存永远是够用的，但是事实不尽然所以会存在缺页的情况。根据 Linux 的异常处理方式最终会将缺页异常的 PTE 交由统一函数处理，而不管性 PTE 的状态。在交由统一函数处理是通常提供错误码来处理。如果需要在 PTE 上进行设计只能可以将 V 置位0，并将其他位标志逐一提供这样就不会异常意义，而缺页异常处理函数会根据 V 的状态判断是否还需要处理
3.双页表与单页表
    略，看理论文章中后期补上..... 防范侧信道攻击、单页表有何优势